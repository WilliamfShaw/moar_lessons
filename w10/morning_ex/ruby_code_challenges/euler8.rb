# require('pry')

###WILL SOLUTION
num = ["73167176531330624919225119674426574742355349194934",
"96983520312774506326239578318016984801869478851843",
"85861560789112949495459501737958331952853208805511",
"12540698747158523863050715693290963295227443043557",
"66896648950445244523161731856403098711121722383113",
"62229893423380308135336276614282806444486645238749",
"30358907296290491560440772390713810515859307960866",
"70172427121883998797908792274921901699720888093776",
"65727333001053367881220235421809751254540594752243",
"52584907711670556013604839586446706324415722155397",
"53697817977846174064955149290862569321978468622482",
"83972241375657056057490261407972968652414535100474",
"82166370484403199890008895243450658541227588666881",
"16427171479924442928230863465674813919123162824586",
"17866458359124566529476545682848912883142607690042",
"24219022671055626321111109370544217506941658960408",
"07198403850962455444362981230987879927244284909188",
"84580156166097919133875499200524063689912560717606",
"05886116467109405077541002256983155200055935729725",
"71636269561882670428252483600823257530420752963450"].join("")

def adjProduct(num)
   results = []
   array = num.split('').map {|x| x.to_i}
   # p array.each_cons(13) {|x| p x }
   array.each_cons(13) {|x| results.push(x.reduce(:*))}
   puts results.max
end

adjProduct(num)

def adjProduct2(num)
largest_product = 0
  counter = 0
  string_num_array = num.split('')
  num_array = string_num_array.map { |x| x.to_i }
  while counter < num_array.length do
    range = (counter..(counter + 12))
    product = num_array[range].reduce(:*)
    if product > largest_product
      largest_product = product
      counter += 1
    else
      counter += 1
    end
  end
  puts largest_product
end

adjProduct2(num)

###MCK SOLUTION
number_string = '7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450'

largest = 0
i = 0
last_set_idx = number_string.length - 13

while i < last_set_idx
  set = number_string[i..i+12].split('').map(&:to_i).reduce(:*)
  largest = set if set > largest
  i += 1
end

puts largest


largest = 0
numbers = number_string.split('').map(&:to_i)
numbers.each_cons(13) do |set|
  product = set.reduce(:*)
  largest = product if product > largest
end
puts largest


### ERIC KWONG SOLUTION

number = 7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450
number_string = number.to_s
product_array = []
i = 0

while i < 988
  thirteen_digits = number_string[i..i+12]
  thirteen_digits_array = thirteen_digits.split("")
  product = 1
  thirteen_digits_array.each { |num| product *= num.to_i }
  product_array << product
  i += 1
end

puts product_array.sort.last

### ERIC DOYLE SOLUTION
number = 7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450

#Make the GIANT Integer a String
number_string = number.to_s
#Split the string...
number_split  = number_string.split('')
#So it can be come an Array
number_array = number_split.map(&:to_i)
#j and k is the starting range of the number_array that we want to multiply
#they will be increased by one to scroll through the while loop
range_start = 0
range_end = 12
#large_number has to be set to 0 to be declared variable.
large_number = 0

while range_start < number_array.length do
  #Every 13 numbers will be multiplied together
  current_number = number_array[range_start..range_end].reduce(:*)

  if current_number > large_number
    #The large number will be saved if its bigger than the current number
    large_number = current_number
  end
  range_start = range_start + 1
  range_end = range_end + 1
end
#And then once the while loop is finished then the results will be posted
puts "The largest number that is a product of 13 adjecent digits is #{large_number}!"



##TONY SOLUTION
def tony_product(num)
	max_product, counter = 0, 0
	while counter < num.length - 13
		product = str_digit_product(num[counter..counter + 12])
		max_product = product if product >= max_product
		counter += 1
	end
	max_product
end

def str_digit_product(num)
	num.split('').map(&:to_i).reduce(:*)
end

puts tony_product(num)

binding.pry

